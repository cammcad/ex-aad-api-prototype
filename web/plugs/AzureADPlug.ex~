defmodule Plug.AzureADPlug do
	import Plug.Conn
	
	def init(options) do
	  # initialize options
		options
	end

	def call(conn, _opts), do: validateConn(conn)

	def validateConn(conn) do
    conn
		|> hasAuthHeader?
		#|> bearerToken?
		#|> hasAppropriatePermissions?
		|> sendback
	end

	defp access_denied(conn,msg) do
		IO.puts "Access denied called!"
		send_resp(conn,401,msg) |> halt
	end

	defp sendback({conn,headers}), do: conn
	defp sendback({conn,:denied}), do: access_denied(conn,"Ooops! You don't have permission to be here.")
	
	#parse out headers to check for authorization header
	defp hasAuthHeader?(conn) do
		try do
			headers = conn.req_headers
			headers = Enum.into(headers,HashDict.new)
			case Dict.has_key?(headers,"authorization") or Dict.has_key?(headers,"Authorization") do
				false -> {conn,:denied}																			
				true ->
					IO.inspect headers
					{conn,headers}
			end
		catch
			_ -> {conn,:denied}
		end
	end

	#check for bearer token
	defp bearerToken?({conn,:denied}), do: {conn,:denied} 
	defp bearerToken?({conn,headers}) do
		try do
			authHeader = Dict.get(headers,"authorization")
			case String.contains?(authHeader,"Bearer") do
				false -> {conn,:denied}
				true ->
					token = String.split(authHeader, " ") |> tl |> hd
					case String.contains?(token,".") do
						false -> {conn,:denied}
						true ->
							token_parts = String.split(token, ".")
							case length(token_parts) == 3 do
								false -> {conn,:denied}
								true ->
									[jwt,claims,_] = token_parts
									case is_binary(jwt) and is_binary(claims) do
										false -> {conn,:denied}
										true -> {conn,Base.url_decode64(jwt),Base.url_decode64(claims)}
									end
							end
					end
			end
		catch
			_ -> {conn,:denied}
		end
	end
	

	#check for appropriate permissions to allow the request though via (claims validation).
	#To take this step a bit further, we could call the azure active directory graph api
	#with the claims information to get more permission details about the user issuing this request.
	#For now... to illustrate the point we're just going to check to make sure that the first part of
	#the token is jwt compliant and that the request is only allowed for active directory user
	# cammcad@cameronfrederickmsn.onmicrosoft.com
	defp hasAppropriatePermissions?({conn,:denied}), do: {conn,:denied}
	defp hasAppropriatePermissions?({conn,jwt,claimsInfo}) do
		try do
			{:ok,jwt} = jwt
			case JSX.is_json? jwt do
				false -> {conn,:denied}
				true ->
					{:ok,jwtMap} = JSX.decode jwt
					case isValidJWT? jwtMap do
						true ->
							{:ok,claimsInfo} = claimsInfo
							case JSX.is_json? claimsInfo do
								false -> {conn,:denied}
								true ->
									{:ok,claimsMap} = JSX.decode claimsInfo
									case isValidClaim(claimsMap) do
										true -> conn #return the connection so that the controller action logic can fire!
										_ -> {conn,:denied}
									end
							end
						_ -> {conn,:denied}
					end
			end
		catch
			_ -> {conn,:denied}
		end
	end
	#ensure that we have a valid jwt
	defp isValidJWT?(jwtMap) do
		hasTyp = hasProp?(jwtMap,"typ")
		case hasTyp and jwtMap["typ"] == "JWT" do
			true ->
				hasAlg = hasProp?(jwtMap,"alg")
				case hasAlg and jwtMap["alg"] == "RS256" do
					true -> hasProp?(jwtMap,"x5t")
					_ -> false
				end
			_ -> false
		end
	end

	#ensure that we have a valid claim, very simplistic implementation
	#that just ensures that the active directory user is cammcad@cameronfrederickmsn.onmicrosoft.com
	#this is where we could call back to Azure AD for permissions that have been granted to the user
	#who issues this request.
	defp isValidClaim(claimMap) do
		hasUpn = hasProp?(claimMap,"upn")
		(hasUpn and claimMap["upn"] == "cammcad@cameronfrederickmsn.onmicrosoft.com")
	end
	#helper 
	defp hasProp?(map,key), do: Dict.has_key?(map,key)
end
